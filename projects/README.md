---
File: my-drives/README.md
Contact: wu.j.kevin@protonmail.ch
Last Modified: February 02, 2026
---

# ./projects/

Directory containing various workspaces for different projects.

---

## Contents

TBD

---

## TBD

Python

You would typically navigate to the project's root directory (my-project/) and activate a Python interpreter to test or run modules:

.venv

```text
my-project/
├── src/
│   └── my_project/
│       ├── __init__.py
│       ├── module.py
│       ├── utils.py
│       ├── config.py
│       ├── models.py
│       └── services.py
├── tests/
│   ├── __init__.py
│   └── test_module.py
├── docs/
│   └── index.md
├── scripts/
│   └── setup_env.sh
├── pyproject.toml
├── requirements.txt
├── README.md
└── LICENSE
```

src/: Contains the main source code. Placing code here helps prevent import issues during testing and installation.

my_project/: The actual Python package. The name uses underscores to comply with Python's import syntax.

tests/: Holds test cases, typically using frameworks like pytest or unittest.

docs/: Contains project documentation, which can be processed using tools like Sphinx or MkDocs.

scripts/: Includes utility scripts for tasks like setting up the environment or data processing.
medium.com

pyproject.toml: Central configuration file for build systems, dependencies, and tool settings.

requirements.txt: Lists project dependencies for easy installation.

README.md: Provides an overview of the project, installation instructions, and usage examples.
docs.python-guide.org

LICENSE: Specifies the project's licensing information

Within the Python shell, you can then import and test your modules:

from my_project import module
module.some_function()

This approach ensures that Python recognizes the package structure correctly, especially when using the src/ layout.

src = make sure installed in venv?

---

ROS 2

Yes, you're correct—in ROS 2 development, it's recommended to use underscores (_) rather than hyphens (-) in workspace names.

```text
ros2_ws/
├── src/       # Source code for ROS 2 packages
│   └── my_robot_package/
├── build/     # Intermediate build files (generated by colcon)
├── install/   # Installed packages and setup files (generated by colcon)
└── log/       # Build and run logs (generated by colcon)
```

src/: This is where you place your ROS 2 packages. It's the only directory you manually populate.
medium.com

build/, install/, log/: These directories are automatically generated by colcon during the build process.

Development tasks, such as building packages or sourcing the environment, are performed from the workspace's root directory (ros2_ws/). For example:

cd ros2_ws/
colcon build
source install/setup.bash

This setup allows you to build all packages within the src/ directory and ensures that the environment is correctly configured for running ROS 2 nodes.

Yes, it's accurate to say that development activities for Python projects, ROS 2 workspaces, and ROS 2 packages typically occur within their respective top-level directories. Let's explore each scenario:

---

ROS 2 Package

Similarly, for ROS 2 packages, the recommended naming convention is to use lowercase letters with underscores to separate words. This aligns with Python's module naming conventions and ensures compatibility across different systems. For instance, a package might be named my_robot_navigation.

```text
my_robot_package/
├── package.xml           # Package metadata
├── CMakeLists.txt        # Build instructions (for C++ packages)
├── setup.py              # Build instructions (for Python packages)
├── setup.cfg             # Additional setup configurations (for Python packages)
├── resource/             # Resource files (for Python packages)
├── my_robot_package/     # Python modules (for Python packages)
│   ├── __init__.py
│   └── node.py
├── include/              # Header files (for C++ packages)
│   └── my_robot_package/
│       └── header.hpp
├── src/                  # Source files (for C++ packages)
│   └── node.cpp
├── launch/               # Launch files
├── config/               # Configuration files (e.g., YAML)
├── msg/                  # Message definitions
├── srv/                  # Service definitions
├── action/               # Action definitions
├── urdf/                 # Robot description files
├── rviz/                 # RViz configuration files
├── test/                 # Test files
└── README.md             # Package documentation
```

package.xml: Defines package information and dependencies.

CMakeLists.txt: Specifies build instructions using CMake (for C++ packages).

setup.py and setup.cfg: Define build and installation instructions (for Python packages).

resource/ and my_robot_package/: Contain Python modules and resources.

include/ and src/: Contain header and source files for C++ packages.
automaticaddison.com+2medium.com+2docs.elephantrobotics.com+2

launch/, config/, msg/, srv/, action/, urdf/, rviz/, test/: Organize various aspects of the package, such as launch configurations, parameters, custom messages, services, actions, robot descriptions, visualization settings, and tests.

While the package resides within the src/ directory of the workspace, development activities specific to the package, such as editing node.py or modifying launch files, occur within the package's directory (my_robot_package/).

However, building the package and running nodes are typically executed from the workspace's root directory:

cd ros2_ws/
colcon build --packages-select my_robot_package
source install/setup.bash
ros2 run my_robot_package node

This approach maintains a clear separation between package-specific development and workspace-level operations.

---

Port Python Package

Option B: Direct Copy

Alternatively, you can copy the my_project/ directory into your ROS 2 package directory.

Python Import:

Ensure that the my_project/ directory contains an __init__.py file to make it a Python package. Then, in your ROS 2 nodes, you can import functions as:

from my_project.module import function

Note: You may need to adjust the PYTHONPATH environment variable or modify sys.path within your scripts to ensure Python can locate the my_project package.

---

For tighter integration, you can convert my-project into a ROS 2 package.

Steps:

    Navigate to the src/ directory of your ROS 2 workspace:

    cd /path/to/ros2_ws/src

    Create a new ROS 2 package using ament_python:
    ros2-tutorial.readthedocs.io+4theconstruct.ai+4youtube.com+4

    ros2 pkg create my_project --build-type ament_python

    Move your existing Python modules into the newly created my_project/ directory.

    Update the setup.py and package.xml files to include necessary dependencies and configurations.

    Build the workspace:
    docs.ros.org+1answers.ros.org+1

    cd /path/to/ros2_ws
    colcon build

    Source the setup script:

    source install/setup.bash

Python Import:

Now, in other ROS 2 packages within the same workspace, you can import functions from my_project as:

from my_project.module import function

---

## Project Directory Structure

Stick to a well-organized directory structure for readability, maintability, and collaboration.  You can use one of the layouts suggested for Python development later on, keep or adapt what a remote GitHub repository used, or choose your own.

Refer to the `project-layout.md` description in the `docs/` folder for layout templates.

Regardless of what you choose, try to also incorporate the additional suggestions under **What Else to Include**.

### Layouts for Python Development

Start with a **flat** layout for simplicity (e.g., Python-only application) or a **src** layout for multiple required installations.  

**flat layout**
```text
    project-name/
    ├── pyproject.toml  # [project], [project.scripts], [build-system]
    ├── README.md
    └── project_name/
        ├── __init__.py # can be empty, but does dictate import behavior
        └── module.py   # def hello(): print("...")
```

**src layout**
```text
    project-name/
    ├── pyproject.toml      # [project], [project.scripts], [build-system]
    ├── README.md
    └── src
        └── project_name/
            ├── __init__.py # can be empty
            └── module.py   # def hello(): print("...")
```

Find `project-layout.md` in the `docs/` folder or go to the [Python packaging manual](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/) for more info.

### What Else to Include

Depending on what other content is relevant, you may want to add more sub-folders.  This is especially true for project-specific data and documents.

Consider adding the following.

**data/**

Datasets used for, collected by, and post-processed from project.  You may find it helpful to also include an additional Markdown or text file to track a catalog of the data available.

Here is an example recommendation, using sub-folders `raw/`, `processed/` and `external/`:

```text
    project-name/
    ├── ...
    ...
    ├── data/
    │   ├── raw/        # original, immutable data (e.g., sensor collection)
    │   ├── processed/  # derived or post-processed from raw
    │   ├── external/   # external sources
    │   └── README.md
    ...
```

**doc/**

Project-specific documentation, if not already in a higher-level `docs/` folder.  For particularly relevant material, it may be worthwhile to add (e.g., sensor specifications) even if it already exists in `docs/` or another location.

**notebooks/, scripts/, *etc.***

Standalone or non-packaged scripts, whether in Python, MATLAB, or C++, should be kept in a `scripts/` folder separate from `src/` or the primary module.  These can also be grouped together by a common purpose, like a module; though, at some point, it would be better just to modify the setup and config files to allow the import of that module, e.g., by installation.

You can keep Jupyter notebooks (`.ipynb`), which can track a history of code executions with their corresponding responses, in a separate folder, `notebooks/` as well.

**results/**

Related to `data/`, but content is post-processed to the point where it facilitates analysis (e.g., charts, graphs) or are for production and distribution (e.g., figures for a paper).

Here is an example breakdown by data type:

```text
    project-name/
    ├── ...
    ...
    ├── results/
    │   ├── figures/
    │   └── tables/ 
    ...
```

You can also categorize by something else instead (e.g., purpose, analysis).  A README.md or similar would also be helpful to catalog particularly notable results and conclusions.

**.venv, .conda, or other environment**

Virtual environments are usually generated elsewhere (i.e., by a tool), so don't worry about adding these manually.

**setup, config, dependencies files**

These are the files responsible for telling others how to set up and use this project, most notably by specifying dependencies and build instructions (for package installation).  The specific files this involves depends on the manager.

Here are some common ones:
- **pyproject.toml**: Modern standard for project metadata in human-readable TOML file.
- **.lock** or similar (e.g., **uv.lock**): Cross-platform "lockfile" with more exact information than TOML to resolve versioning in between different systems.
- **environment.yml** or **environment.yaml**: Config file for Conda specifying channels as well as Python and non-Python (e.g., C++) dependencies.
- **requirements.txt**: Barebones list of dependencies used by `pip`.
- **setup.py**: Script used in conjunction with `requirements.txt` by `pip` to install dependencies.

**.git and .gitignore**

Additional metadata needed for distribution to or cloning from remote repository, usually GitHub.

`.gitignore` is usually configured to avoid uploading datasets, virtual environments, and other large-size components.

If cloning from GitHub or another remote, then keeping or adapting the original structure is fine.

### Example

Example for custom project workspace:

```text
project-name/
├── data/
│   ├── raw/  		# sensor collection
│   ├── processed/  # derived sensor signals
│   ├── external/   # benchmark dataset, data from similar test
│   └── README.md
├── doc/
├── notebooks/      # Jupyter notebooks
├── scripts/
│   ├── matlab/     # standalone .m files used to plot data
│   └── python/     # standalone Python scripts as CLI executables
├── src/
│   ├── +your_matlab_pkg/       # can include MATLAB; mind the + prefix
│   ├── project_name/           # note name of import package
│   └── your_other_python_pkg/  # Python packages
├── results/
│   ├── figures/
│   └── tables/
├── environment.yml     # if using Conda and Python
├── requirements.txt    # if using pip and Python
├── README.md
└── LICENSE             # if necessary, or provided by repository
```

Remote repositories may not follow this structure, but feel free to add parts from the template as needed for your own work.

---
